// Generated by CoffeeScript 1.10.0
(function() {
  var invert_obj;

  invert_obj = function(obj) {
    var inv, key, value;
    inv = {};
    for (key in obj) {
      value = obj[key];
      inv[value] = key;
    }
    return inv;
  };

  this.AntRules = (function() {
    AntRules.OP_CODES = {
      move: 0,
      turn: 2,
      set_color: 1,
      on_color: 3
    };

    AntRules.OP_CODES_INV = invert_obj(AntRules.OP_CODES);

    AntRules.COLOR_CODES = {
      black: 0,
      white: 1,
      red: 2,
      green: 3,
      blue: 4,
      cyan: 5,
      yellow: 6,
      magenta: 7,
      "default": 8
    };

    AntRules.COLOR_CODES_INV = invert_obj(AntRules.COLOR_CODES);

    AntRules.TURN_CODES = {
      left: 0,
      right: 1
    };

    AntRules.TURN_CODES_INV = invert_obj(AntRules.TURN_CODES);

    AntRules.MOVE_CODES = {
      forward: 0,
      backward: 1
    };

    AntRules.MOVE_CODES_INV = invert_obj(AntRules.MOVE_CODES);

    function AntRules() {
      var color;
      for (color in AntRules.COLOR_CODES) {
        this[color] = [];
      }
      this["default"] = ["forward"];
    }

    AntRules.prototype.load_obj = function(obj) {
      var color, key, value;
      for (color in AntRules.COLOR_CODES) {
        this[color] = [];
      }
      for (key in obj) {
        value = obj[key];
        this[key] = value.slice();
      }
      return this;
    };

    AntRules.prototype.encode = function() {
      var COLOR_CODES, MOVE_CODES, OP_CODES, TURN_CODES, code, color, j, len, rule, rules;
      COLOR_CODES = AntRules.COLOR_CODES;
      OP_CODES = AntRules.OP_CODES;
      MOVE_CODES = AntRules.MOVE_CODES;
      TURN_CODES = AntRules.TURN_CODES;
      code = "";
      for (color in COLOR_CODES) {
        rules = this[color];
        if (rules.length > 0) {
          code += OP_CODES.on_color;
          code += COLOR_CODES[color];
          for (j = 0, len = rules.length; j < len; j++) {
            rule = rules[j];
            if (rule in COLOR_CODES) {
              code += OP_CODES.set_color;
              code += COLOR_CODES[rule];
            } else if (rule in TURN_CODES) {
              code += OP_CODES.turn;
              code += TURN_CODES[rule];
            } else if (rule in MOVE_CODES) {
              code += OP_CODES.move;
              code += MOVE_CODES[rule];
            } else {
              console.error("Invalid rule: " + rule);
            }
          }
        }
      }
      return code;
    };

    AntRules.prototype.decode = function(code) {
      var COLOR_CODES_INV, MOVE_CODES_INV, OP_CODES, OP_CODES_INV, TURN_CODES_INV, arg, color, color_key, i, j, op_code, ref;
      OP_CODES = AntRules.OP_CODES;
      COLOR_CODES_INV = AntRules.COLOR_CODES_INV;
      OP_CODES_INV = AntRules.OP_CODES_INV;
      MOVE_CODES_INV = AntRules.MOVE_CODES_INV;
      TURN_CODES_INV = AntRules.TURN_CODES_INV;
      for (color in AntRules.COLOR_CODES) {
        this[color] = [];
      }
      color_key = null;
      for (i = j = 0, ref = Math.floor(code.length / 2); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        op_code = parseInt(code[2 * i]);
        arg = parseInt(code[2 * i + 1]);
        switch (op_code) {
          case OP_CODES.on_color:
            color_key = COLOR_CODES_INV[arg];
            break;
          case OP_CODES.set_color:
            this[color_key].push(COLOR_CODES_INV[arg]);
            break;
          case OP_CODES.turn:
            this[color_key].push(TURN_CODES_INV[arg]);
            break;
          case OP_CODES.move:
            this[color_key].push(MOVE_CODES_INV[arg]);
        }
      }
      return this;
    };

    return AntRules;

  })();

}).call(this);
